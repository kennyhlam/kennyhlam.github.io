<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technology on Ramblings and Wonderings</title>
    <link>https://kennyhlam.github.io/tags/technology/</link>
    <description>Recent content in Technology on Ramblings and Wonderings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 14 Aug 2016 00:30:46 +0000</lastBuildDate>
    <atom:link href="https://kennyhlam.github.io/tags/technology/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang Web Frameworks</title>
      <link>https://kennyhlam.github.io/2016/08/golang-web-frameworks</link>
      <pubDate>Sun, 14 Aug 2016 00:30:46 +0000</pubDate>
      
      <guid>https://kennyhlam.github.io/2016/08/golang-web-frameworks</guid>
      <description>&lt;p&gt;In my spirit of wanting to work on something new using golang, I started with the server. But where on earth to start?! Usually there&amp;rsquo;s some de-facto standard that each language lives with: Rails and Sinatra for Ruby, Django for Python, Spring for Java (I think, I don&amp;rsquo;t really write Java nowadays). Now, these might just be standards for the hobbyist, but they&amp;rsquo;re incredibly popular, well-supported, and well-documented.&lt;/p&gt;

&lt;p&gt;Where the heck to start with for golang? A quick google search could only provide me with an abundance of disjoint results (not in order):&lt;/p&gt;




    &lt;ul&gt;
    
        
            &lt;li&gt;&lt;a href=&#34;http://beego.me/&#34;&gt;Beego&lt;/a&gt;&lt;/li&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://echo.labstack.com/&#34;&gt;Echo&lt;/a&gt; (as a side note, echo is a bad name in case you ever end up with an echo binary)&lt;/li&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://gin-gonic.github.io/gin/&#34;&gt;Gin&lt;/a&gt;&lt;/li&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://goji.io/&#34;&gt;Goji&lt;/a&gt;&lt;/li&gt;
        
            &lt;li&gt;&lt;a href=&#34;http://iris-go.com/&#34;&gt;Iris&lt;/a&gt;&lt;/li&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://github.com/go-martini/martini&#34;&gt;Martini&lt;/a&gt;&lt;/li&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://revel.github.io/&#34;&gt;Revel&lt;/a&gt;&lt;/li&gt;
        

    
    &lt;/ul&gt;




&lt;p&gt;A quick browse of &lt;a href=&#34;https://golanglibs.com/category/web-framework?sort=top&#34;&gt;popular ones&lt;/a&gt; added more into the mix:&lt;/p&gt;

&lt;p&gt;And some people even suggest just write your own stack using net/http.&lt;/p&gt;

&lt;p&gt;Of course, a variety of people have their own &lt;a href=&#34;https://www.quora.com/Which-web-framework-for-the-Go-language-is-best-for-creating-a-REST-API&#34;&gt;opinions&lt;/a&gt; and &lt;a href=&#34;http://blog.honeybadger.io/go-write-a-web-app-five-interesting-go-web-frameworks/&#34;&gt;analysis&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Alright, so we&amp;rsquo;ve got a big bag of vaguely indistinguishable options, so how do we choose? Like all decisions, ill-informed decision-making is a deathknell, so we have to learn about each one as best we can.&lt;/p&gt;

&lt;p&gt;The criteria I&amp;rsquo;ll be using to decide are generally the criteria you can use to choose for any software-related decision, and they include the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Usage (how well does it do the job, how good does it feel to build using the framework)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Maturity (how popular is it, how widely used is it)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Stability (not unrelated to maturity, but how well is this supported)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Documentation (if I get stuck, how well do the docs describe what&amp;rsquo;s going on)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Design (how did the authors layout the code and choose how it operates)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Performance (is it fast enough)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Supportability (if other people joined the project, how comfortable would they be reading my code)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Clarity (does the framework impose odd or unusual constraints on our code or have weird idioms)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Licensing (how friendly are its terms)&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here is a general breakdown of my feelings on each framework:&lt;/p&gt;




    &lt;ul&gt;
    
        
            &lt;li&gt;&lt;a href=&#34;http://beego.me/&#34; style=&#34;font-weight: 600;&#34;&gt;Beego&lt;/a&gt; -  A full-featured framework, Beego offers much in the way of the tools that a developer might want. While I think the docs could go a ways in setting some patterns that developers could follow, it offers an abundance of features and you won&amp;#39;t be wanting with this framework.&lt;/li&gt;
            &lt;p style=&#34;font-size: 13px&#34;&gt;Beego takes its history from a variety of other popular web frameworks from other languages. It takes its roots from Asia, where it seems a few of the companies are using it in production. The website provides a very straightforward example, along with a plethora of documentation (including figures, figures!) speaking to each element of the framework. It outlines pretty much every stage in its pipeline and has a lot of examples on how to do pretty much everything related to the application. The big question is whether or not it&amp;#39;s popular outside of Asia and if not, why so. Perhaps a language barrier, or perhaps a lack of popularity of golang. Either way, major points to this framework for its thorough documentation and full-featured components.&lt;/p&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://echo.labstack.com/&#34; style=&#34;font-weight: 600;&#34;&gt;Echo&lt;/a&gt; -  Echo says its high speed is what sets it apart, and it seems easy enough to use. However, it seems to offer fewer features than its competitors and the website is less than thorough for newcomers.&lt;/li&gt;
            &lt;p style=&#34;font-size: 13px&#34;&gt;Echo seems a framework similar to Gin (and I supposed Martini by extension). Again, touts its lightweight-ness and fast routing, along with flexible middleware extensibility. It seems to have hit v2 with its API, and it offers some interesting capabilities over Gin. Specifically, it has unique handling of binding of input into objects (though still lacking and ORM) and application of middleware to only specific groups or routes. At the end, however, it seems immature by its website, due to a dearth of real documentation or enough examples. Still a contender, but the website is lacking in a variety of aspects, which reflects poorly on the product.&lt;/p&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://gin-gonic.github.io/gin/&#34; style=&#34;font-weight: 600;&#34;&gt;Gin&lt;/a&gt; -  A v1.0 framework with support for middlewares and lightweight routing, but possibly with slow or stalled development. It primarly touts itself as Martini with incredibly high performance. A definite contender.&lt;/li&gt;
            &lt;p style=&#34;font-size: 13px&#34;&gt;The first thing Gin claims is super high performance. When I had previously played with Golang, Martini was still the de-facto standard for web frameworks, so that&amp;#39;s quite a bold claim to be up to 40x faster than Martini. It uses one of those fancy routers that uses one of those nobody-ever-writes-that-stuff algorithms (but really, Radix trees are incredibly cool and powerful; if you don&amp;#39;t know what they are or what they can do, I strongly suggest it) which you only hear about in theory. Basically what I can get off their webpage is that they are Martini&amp;#43;&amp;#43;, where the big draw is performance and the clarity that Martini brought. The github page has a few examples, and it seems that they&amp;#39;ve reached 1.0, so things are stable. After reading some of the examples, it provides a very lightweight webframework for routing and handling of requests, but lacks some of the features you&amp;#39;d find in a more full-blown framework, such as an ORM. At the time of writing, it seems the last development on any of the branches was done around 4 months ago or so, which is a little dis-heartening. I think it offers the ability to plug in a number of middlewares, but the lack of current development makes me a sad panda. Not the end of the world, and I wonder if I so desperately need incredibly high performance, but still a strong contender.&lt;/p&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://goji.io/&#34; style=&#34;font-weight: 600;&#34;&gt;Goji&lt;/a&gt; -  While a nice website, it lacks any real documentation or examples. For this reason, I can&amp;#39;t really choose this as my framework of choice&lt;/li&gt;
            &lt;p style=&#34;font-size: 13px&#34;&gt;There&amp;#39;s not too much to say about Goji; the website kind of says it all. A very minimalistic approach to a website, but it lacks enough examples or enough documentation for me to justify going with it.&lt;/p&gt;
        
            &lt;li&gt;&lt;a href=&#34;http://iris-go.com/&#34; style=&#34;font-weight: 600;&#34;&gt;Iris&lt;/a&gt; -  Iris is a rather full-featured framework that offers good documentations and examples. It&amp;#39;s actively developed and brings a lot to the table; a top-choice for any web project in Golang.&lt;/li&gt;
            &lt;p style=&#34;font-size: 13px&#34;&gt;Iris brings about a lot of bragging, if you will, on its homepage. Whether it&amp;#39;s well deserved is unclear, but it provides a number of useful pages in its documentation as well as a number of examples. The sheer size of the menu can be intimidating. Overall, it provides a relatively clean sytax with some flexibility that can be neatly organized. However much of a godsend this might seem, it does have its drawbacks, such as lack of features that one might want, such as automatic migration handling. The examples are also generally half-baked small examples in the range of a few dozen lines, as opposed to a full-blown example. The developer also makes odd points sometimes, such as his choice of &amp;#39;party&amp;#39; for an API grouping due to its [fun](https://godoc.org/github.com/kataras/iris#Framework.Party). Also, the good people at [reddit](https://www.reddit.com/r/golang/comments/4ot75d/katarasiris_the_fastest_web_framework_for_go_in/) keep you on track to point out there are very few tests, which is a bit disconcerting. The godocs themselves also point to some messiness on the part of the developer, with malformed syntax issues.&lt;/p&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://github.com/go-martini/martini&#34; style=&#34;font-weight: 600;&#34;&gt;Martini&lt;/a&gt; -  A no-longer maintained framework, it had its high point, but I would rather choose something actively supported&lt;/li&gt;
            &lt;p style=&#34;font-size: 13px&#34;&gt;Probably one of the earlier web frameworks which gained traction in the Golang community, Martini provides a light-weight and simple sinatra-style interface to HTTP routing and handling. However, it is no longer maintained. Whether because it has reached a peak maturity, a lack of community, or because the maintainer no longer has time, it supports only up to gov1.1. As such, I&amp;#39;m ruling it out because it would quickly fall behind and get out-dated with new version of Golang.&lt;/p&gt;
        
            &lt;li&gt;&lt;a href=&#34;https://revel.github.io/&#34; style=&#34;font-weight: 600;&#34;&gt;Revel&lt;/a&gt; -  One of the new kids on the block, Revel is home to many developer-craved features. If you&amp;#39;re okay trying something in flux, then this is for you.&lt;/li&gt;
            &lt;p style=&#34;font-size: 13px&#34;&gt;At the end of the day, Revel seems to offer many of the features that any developer would want in their web framework. It&amp;#39;s got great documentation and a fair share of examples on its homepage. It follows a very familiar design of one thread per request, and it built as a layer on top of the Golang HTTP server. It offers a variety of options familiar to the Rails framework in Ruby, including similar routing and layout of user-generated content (controllers, templates/views). It even offers more transparency in its middleware and callbacks for before/after request handling. However, it lacks an ORM and the model portion of MVC. Stated on their own website, they are pre-1.0 as of this writing, and a high rate of change is still expected. Seeing as this was the top hit on Google, I&amp;#39;m not disappointed. Whether it took inspiration from other frameworks or the developers have a keen mind for design, it touts a boat of helpful features and clean documentation as well as samples. The scary part of using this is the &amp;#39;rate of change is still high&amp;#39; and &amp;#39;early adopters only&amp;#39;. I&amp;#39;m incredibly excited for what this can become, but it&amp;#39;s a bit too immature for me to want to move forward with it. I think in the future this could be the go-to choice for Golang, but maybe in a few months after it hits 1.0.&lt;/p&gt;
        

    
    &lt;/ul&gt;




&lt;p&gt;I really liked Iris&amp;ndash;it offers a number of useful features that developers would need and it has a plethora of documentation. However, it&amp;rsquo;s lack of testing, documentation issues, and seeming lack of maturity on the part of the developer would have to lead me away from it (immaturity on the part of the developers is possibly scarier than anything).&lt;/p&gt;

&lt;p&gt;At the end of the day, only one other of these frameworks really made me feel comfortable enough to try using, and that&amp;rsquo;s Beego. It&amp;rsquo;s full-featured, has copious amounts of documentation, and is stable so that a real amount of development can get done. It&amp;rsquo;s also used by a variety of different companies in production, so it definitely checks the boxes for stability and support. I&amp;rsquo;m not quite sure my needs for performance, but I can say with some confidence that my project is very niche and that unless it&amp;rsquo;s performance is a crawl, it&amp;rsquo;ll definitely fulfill my needs.&lt;/p&gt;

&lt;p&gt;Also, don&amp;rsquo;t get me wrong; while you can simply pick a tool cause it fulfills your needs, for a personal project, you should definitely pick something that&amp;rsquo;s fun (something you do in your spare time should be fun, after all). Sticking with golang is a personal choice, but if I didn&amp;rsquo;t feel like using Beego was a good experience, I would definitely have moved over to Python or something else. Having done some starter work with it, I can definitely tell you that the modularity it provides makes it feel so clean and nice to work with. Until I find major issues with it, I can safely say that I would definitely recommend it if you&amp;rsquo;re looking to start a web project with golang.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting Started</title>
      <link>https://kennyhlam.github.io/2016/08/getting-started</link>
      <pubDate>Sat, 06 Aug 2016 20:27:35 +0000</pubDate>
      
      <guid>https://kennyhlam.github.io/2016/08/getting-started</guid>
      <description>

&lt;p&gt;So I haven&amp;rsquo;t created a website in quite a while, and well starting a blog has been on my backburner for quite a while. Anyways, I was basically inspired by a friend of mine&amp;rsquo;s blogging to get back into writing (thanks? Dennis). I&amp;rsquo;m hoping that I&amp;rsquo;ll branch back out again into things that aren&amp;rsquo;t technology-related, but this one will be. Let&amp;rsquo;s start at the beginning. I&amp;rsquo;m a back-end engineer, which basically means that anything I&amp;rsquo;ll be making may look&amp;hellip;less than glamorous, but it&amp;rsquo;ll work however it might look.&lt;/p&gt;

&lt;p&gt;To start out, I wanted to use &lt;a href=&#34;https://pages.github.com/&#34;&gt;GitHub Pages&lt;/a&gt; because it&amp;rsquo;s free (but what isn&amp;rsquo;t nowadays?) and because I&amp;rsquo;m a huge fan of GitHub. The alternative was &lt;a href=&#34;https://medium.com/policy/medium-terms-of-service-9db0094a1e0f#.gb3impqcl&#34;&gt;Medium&lt;/a&gt;, and they got some flak in the past about their Terms of Service and basically being able to do a bunch of stuff without you knowing/having your explicit consent, but they&amp;rsquo;ve since &lt;a href=&#34;https://github.com/Medium/medium-policy/commit/8d5f24a5c603a8ed9d0edaf3a7fc13a8a031a123&#34;&gt;gotten friendlier terms&lt;/a&gt;. Now, I&amp;rsquo;m not particularly worried about my blog getting re-produced, but it is nice to have the feeling that your output is your own, and Github has a great set of terms related to &lt;a href=&#34;https://help.github.com/articles/github-terms-of-service/&#34;&gt;content ownership&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In any case, though, Medium has a very sexy look and feel to it, but the big issue is that I would only be working on writing; I wanted to work on something where I&amp;rsquo;d be learning something else, and what better way to learn things than to customize the heck out of your own blog! GitHub Pages is also super easy to use, where everything is just a &lt;code&gt;git push -f&lt;/code&gt; away! There&amp;rsquo;s a whole bunch of other services which provide free/cheap hosting (Heroku, DigitalOcean, Amazon, etc. etc.), but there&amp;rsquo;s usually some amount of configuration and such to get it to hook into your repo, so why add in an extra middle-man when you can go directly to a repo itself.&lt;/p&gt;

&lt;p&gt;The good people at Github recommend using a static website generator to help with the process, and they recommend &lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;. Woe is me, there had to be another option! I write a bunch of Ruby code at work, and I can tell you that Ruby is awful. I mean it&amp;rsquo;s syntactic sugar, just like Python&amp;ndash;you can basically write down some English and there&amp;rsquo;s a good chance it&amp;rsquo;ll run. The issue though, is that it&amp;rsquo;s &lt;a href=&#34;http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=yarv&amp;amp;lang2=go&#34;&gt;slow&lt;/a&gt;, and it&amp;rsquo;s got bad support for almost-kind-of-maybe-sure-but-jokes-no &amp;ldquo;threads&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a few &lt;a href=&#34;https://www.sitepoint.com/6-static-blog-generators-arent-jekyll/&#34;&gt;options&lt;/a&gt; out there, but I won&amp;rsquo;t &lt;a href=&#34;https://www.smashingmagazine.com/2015/11/static-website-generators-jekyll-middleman-roots-hugo-review/&#34;&gt;list&lt;/a&gt; them all. In the end, I wanted something that wasn&amp;rsquo;t Ruby so I could learn something new, and I have a huge crush on golang, so Hugo was the obvious choice.&lt;/p&gt;

&lt;p&gt;I followed the &lt;a href=&#34;https://gohugo.io/overview/quickstart/&#34;&gt;quickstart guide&lt;/a&gt; and quickly got started picking a theme, here are some of my favorites:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://themes.gohugo.io/hugo-identity-theme/&#34;&gt;identity&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://themes.gohugo.io/material-design/&#34;&gt;material-design&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://themes.gohugo.io/strata/&#34;&gt;strata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://themes.gohugo.io/hugo-zen/&#34;&gt;zen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I chose the minimalist theme for what you&amp;rsquo;re seeing now.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re like me, you sure didn&amp;rsquo;t follow the guide to a tee. In the guide, though, they do say you can have sections of your website like &lt;code&gt;blog&lt;/code&gt;, &lt;code&gt;article&lt;/code&gt; or &lt;code&gt;tutorial&lt;/code&gt;. However, you should be careful which template you&amp;rsquo;re using, since mine wasn&amp;rsquo;t rendering really anything cause I had run&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo new blog/getting-started.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Turns out some of the templates specifically look for keys like &lt;code&gt;post&lt;/code&gt;; a variety of things are key&amp;rsquo;d off this, including the RSS feeds, so if you&amp;rsquo;re deviating from the norm, be careful to go over and find the references. If you&amp;rsquo;re like me, and you happen to be using a VM to do your development, you may also run into issues&amp;ndash;you really want to bind to all addresses, &lt;code&gt;0.0.0.0&lt;/code&gt;. The last little tidbit is that you basically want to copy all the &lt;code&gt;layouts&lt;/code&gt; and &lt;code&gt;static&lt;/code&gt; from the themes into your own Hugo directory (I imagine this is how they meant for people to use this). It becomes really confusing to keep track of where exactly you are in the directory when there&amp;rsquo;s a nested theme that has the same directory structure, so copying them into your top-level Hugo directory overrides the theme&amp;rsquo;s defaults.&lt;/p&gt;

&lt;p&gt;At the end of the day, what you really want is probably (note http for local development)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo server --buildDrafts --bind 0.0.0.0 --baseUrl=http://&amp;lt;YOUR IP&amp;gt;/ 2&amp;gt;&amp;amp;1 &amp;gt; /dev/null &amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;for Hugo to silently run in the background with it&amp;rsquo;s auto-update feature.&lt;/p&gt;

&lt;p&gt;When you finally finish, careful that in your &lt;code&gt;config.toml&lt;/code&gt;, you have &lt;code&gt;https&lt;/code&gt; if you&amp;rsquo;re using Github Pages. At least for Chrome, you&amp;rsquo;ll get mixed content messages (meaning some assets are &lt;code&gt;https&lt;/code&gt; and some are &lt;code&gt;http&lt;/code&gt;), but since your Github Pages url is &lt;code&gt;https&lt;/code&gt;, you&amp;rsquo;ll be missing resources and your website will look like it hasn&amp;rsquo;t loaded its css (since it hasn&amp;rsquo;t).&lt;/p&gt;

&lt;h2 id=&#34;final-thoughts&#34;&gt;Final thoughts&lt;/h2&gt;

&lt;p&gt;Hugo seems like a rather opinionated framework for static website generation, which isn&amp;rsquo;t necessarily a bad thing. However, it&amp;rsquo;s relatively young, and that&amp;rsquo;s always a bit risky. I haven&amp;rsquo;t finished reading the docs (much more of a do-er than a read-er), and some things do feel a bit clunky (you can only &lt;code&gt;hugo&lt;/code&gt; in the top level where your &lt;code&gt;config.toml&lt;/code&gt; is, when you publish &lt;a href=&#34;https://gohugo.io/overview/usage/&#34;&gt;old assets aren&amp;rsquo;t removed&lt;/a&gt;, there&amp;rsquo;s a lack of helpful feedback such as when I made &lt;code&gt;blog&lt;/code&gt; instead of &lt;code&gt;posts&lt;/code&gt;, etc.) A lot of things feel like they&amp;rsquo;ve been developed so far, but not enough to the point where the defaults suit the typical use-case.&lt;/p&gt;

&lt;p&gt;All that said, though, it was relatively easy to set up and get started with Hugo, and it provides a rather intuitive way to build a static website. While some things can be finessed, such as how to deal with your &lt;code&gt;public&lt;/code&gt; directory and nested git submodules, it looks clean at the end with just some initial startup time, but writing itself was rather streamlined. I haven&amp;rsquo;t tried the other options for website generation, but I&amp;rsquo;m excited at the prospect of Hugo and where it can go in the future.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>